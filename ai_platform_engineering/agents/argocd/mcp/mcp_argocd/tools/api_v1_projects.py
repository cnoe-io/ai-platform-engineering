# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/projects operations"""

import logging
from typing import Dict, Any, List
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("mcp_tools")


async def project_list(
    param_name: str = None, 
    summary_only: bool = True, 
    page: int = 1,
    page_size: int = 20
) -> Dict[str, Any]:
    '''
    List returns a paginated list of projects.

    Args:
        param_name (str, optional): Filter by project name. Defaults to None.
        summary_only (bool, optional): If True, return only summary information (default: True).
        page (int, optional): Page number (1-indexed, default: 1).
        page_size (int, optional): Number of items per page (default: 20, max: 100).

    Returns:
        Dict[str, Any]: Paginated list of projects with metadata:
        {
            "items": [...],
            "pagination": {
                "page": 1,
                "page_size": 20,
                "total_items": 50,
                "total_pages": 3,
                "has_next": true,
                "has_prev": false
            }
        }
    '''
    logger.debug("Making GET request to /api/v1/projects")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    flat_body = {}
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/projects", method="GET", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}

    # Enforce pagination limits
    page = max(1, page)
    page_size = min(100, max(1, page_size))

    all_items = response.get("items", [])
    total_items = len(all_items)
    total_pages = (total_items + page_size - 1) // page_size

    # Calculate pagination slice
    start_idx = (page - 1) * page_size
    end_idx = start_idx + page_size
    
    # Check if page is out of bounds
    if start_idx >= total_items and total_items > 0:
        return {
            "error": f"Page {page} out of bounds. Total pages: {total_pages}",
            "pagination": {
                "page": page,
                "page_size": page_size,
                "total_items": total_items,
                "total_pages": total_pages,
                "has_next": False,
                "has_prev": page > 1
            }
        }

    paginated_items = all_items[start_idx:end_idx]

    # Build pagination metadata
    pagination_meta = {
        "page": page,
        "page_size": page_size,
        "total_items": total_items,
        "total_pages": total_pages,
        "has_next": page < total_pages,
        "has_prev": page > 1,
        "showing_from": start_idx + 1 if paginated_items else 0,
        "showing_to": start_idx + len(paginated_items)
    }

    # If summary_only is True, return only essential information
    if summary_only:
        summary_items = []
        for project in paginated_items:
            summary_item = {
                "name": project.get("metadata", {}).get("name", ""),
                "description": project.get("spec", {}).get("description", ""),
                "source_repos": project.get("spec", {}).get("sourceRepos", []),
                "destinations": project.get("spec", {}).get("destinations", []),
                "cluster_resource_whitelist": project.get("spec", {}).get("clusterResourceWhitelist", []),
                "namespace_resource_whitelist": project.get("spec", {}).get("namespaceResourceWhitelist", []),
                "roles": project.get("spec", {}).get("roles", []),
                "sync_windows": project.get("spec", {}).get("syncWindows", []),
                "orphaned_resources": project.get("spec", {}).get("orphanedResources", {}),
                "signature_keys": project.get("spec", {}).get("signatureKeys", []),
                "creation_timestamp": project.get("metadata", {}).get("creationTimestamp", ""),
                "generation": project.get("metadata", {}).get("generation", ""),
                "resource_version": project.get("metadata", {}).get("resourceVersion", ""),
            }
            summary_items.append(summary_item)

        return {
            "items": summary_items,
            "pagination": pagination_meta,
            "summary_only": True
        }

    return {
        "items": paginated_items,
        "pagination": pagination_meta
    }


async def project_create(
    name: str,
    description: str = None,
    destinations: List[dict] = None,
    sourceRepos: List[str] = None,
    upsert: bool = False,
    labels: Dict[str, Any] = None,
    annotations: Dict[str, Any] = None,
) -> Dict[str, Any]:
    """
    Create a new ArgoCD project.

    Args:
        name (str): Name of the project (required).
        description (str, optional): Description of the project.
        destinations (List[dict], optional): List of allowed destinations (each dict should have 'server' and 'namespace').
        sourceRepos (List[str], optional): List of allowed source repositories.
        upsert (bool, optional): Whether to upsert the project if it exists.
        labels (Dict[str, Any], optional): Labels for the project.
        annotations (Dict[str, Any], optional): Annotations for the project.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    """
    logger.debug("Making POST request to /api/v1/projects")

    params = {}
    if upsert:
        params["upsert"] = True

    # Build the minimal project body
    flat_body = {
        "project_metadata_name": name,
    }
    if labels is not None:
        flat_body["project_metadata_labels"] = labels
    if annotations is not None:
        flat_body["project_metadata_annotations"] = annotations

    if description is not None:
        flat_body["project_spec_description"] = description
    if destinations is not None:
        flat_body["project_spec_destinations"] = destinations
    if sourceRepos is not None:
        flat_body["project_spec_sourceRepos"] = sourceRepos

    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/projects", method="POST", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response

async def project_delete(param_name: str = None) -> Dict[str, Any]:
    '''
    Delete a project.

    Args:
        param_name (str, optional): OpenAPI parameter corresponding to 'param_name'. Defaults to None.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    '''
    logger.debug("Making DELETE request to /api/v1/projects/{name}")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    success, response = await make_api_request(f"/api/v1/projects/{param_name}", method="DELETE", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response

async def project_get(param_name: str = None) -> Dict[str, Any]:
    '''
    Get a project.

    Args:
        param_name (str, optional): OpenAPI parameter corresponding to 'param_name'. Defaults to None.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    '''
    logger.debug("Making GET request to /api/v1/projects/{name}")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    success, response = await make_api_request(f"/api/v1/projects/{param_name}", method="GET", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response

async def project_update(param_name: str = None) -> Dict[str, Any]:
    '''
    Update a project.

    Args:
        param_name (str, optional): OpenAPI parameter corresponding to 'param_name'. Defaults to None.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    '''
    logger.debug("Making PUT request to /api/v1/projects/{name}")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    success, response = await make_api_request(f"/api/v1/projects/{param_name}", method="PUT", params=params, data=data)
    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response
