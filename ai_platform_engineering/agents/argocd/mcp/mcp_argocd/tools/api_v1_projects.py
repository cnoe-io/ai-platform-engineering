# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/projects operations"""

import logging
from typing import Dict, Any, List
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("mcp_tools")


async def project_list(param_name: str = None, summary_only: bool = True, limit: int = 100) -> Dict[str, Any]:
    '''
    List returns a list of projects.

    Args:
        param_name (str, optional): OpenAPI parameter corresponding to 'param_name'. Defaults to None.
        summary_only (bool, optional): If True, return only summary information (default: True).
        limit (int, optional): Maximum number of projects to return (default: 100).

    Returns:
        Dict[str, Any]: The JSON response from the API call containing the list of projects.

    Raises:
        Exception: If the API request fails or returns an error.
    '''
    logger.debug("Making GET request to /api/v1/projects")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    # Note: ArgoCD API doesn't support limit parameter, so we'll handle it in application logic

    flat_body = {}
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/projects", method="GET", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}

    # If summary_only is True, return only essential information
    if summary_only and "items" in response:
        summary_items = []
        projects = response["items"]

        # Apply limit in application logic since ArgoCD API doesn't support it
        if limit is not None and limit > 0:
            projects = projects[:limit]

        for project in projects:
            summary_item = {
                "name": project.get("metadata", {}).get("name", ""),
                "description": project.get("spec", {}).get("description", ""),
                "source_repos": project.get("spec", {}).get("sourceRepos", []),
                "destinations": project.get("spec", {}).get("destinations", []),
                "cluster_resource_whitelist": project.get("spec", {}).get("clusterResourceWhitelist", []),
                "namespace_resource_whitelist": project.get("spec", {}).get("namespaceResourceWhitelist", []),
                "roles": project.get("spec", {}).get("roles", []),
                "sync_windows": project.get("spec", {}).get("syncWindows", []),
                "orphaned_resources": project.get("spec", {}).get("orphanedResources", {}),
                "signature_keys": project.get("spec", {}).get("signatureKeys", []),
                "creation_timestamp": project.get("metadata", {}).get("creationTimestamp", ""),
                "generation": project.get("metadata", {}).get("generation", ""),
                "resource_version": project.get("metadata", {}).get("resourceVersion", ""),
            }
            summary_items.append(summary_item)

        return {
            "items": summary_items,
            "total": len(summary_items),
            "summary_only": True,
            "limit_applied": limit is not None
        }

    # Handle limit for full response as well
    if "items" in response and limit is not None and limit > 0:
        response["items"] = response["items"][:limit]
        response["total"] = len(response["items"])
        response["limit_applied"] = True

    return response


async def project_create(
    name: str,
    description: str = None,
    destinations: List[dict] = None,
    sourceRepos: List[str] = None,
    upsert: bool = False,
    labels: Dict[str, Any] = None,
    annotations: Dict[str, Any] = None,
) -> Dict[str, Any]:
    """
    Create a new ArgoCD project.

    Args:
        name (str): Name of the project (required).
        description (str, optional): Description of the project.
        destinations (List[dict], optional): List of allowed destinations (each dict should have 'server' and 'namespace').
        sourceRepos (List[str], optional): List of allowed source repositories.
        upsert (bool, optional): Whether to upsert the project if it exists.
        labels (Dict[str, Any], optional): Labels for the project.
        annotations (Dict[str, Any], optional): Annotations for the project.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    """
    logger.debug("Making POST request to /api/v1/projects")

    params = {}
    if upsert:
        params["upsert"] = True

    # Build the minimal project body
    flat_body = {
        "project_metadata_name": name,
    }
    if labels is not None:
        flat_body["project_metadata_labels"] = labels
    if annotations is not None:
        flat_body["project_metadata_annotations"] = annotations

    if description is not None:
        flat_body["project_spec_description"] = description
    if destinations is not None:
        flat_body["project_spec_destinations"] = destinations
    if sourceRepos is not None:
        flat_body["project_spec_sourceRepos"] = sourceRepos

    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/projects", method="POST", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response

async def project_delete(param_name: str = None) -> Dict[str, Any]:
    '''
    Delete a project.

    Args:
        param_name (str, optional): OpenAPI parameter corresponding to 'param_name'. Defaults to None.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    '''
    logger.debug("Making DELETE request to /api/v1/projects/{name}")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    success, response = await make_api_request(f"/api/v1/projects/{param_name}", method="DELETE", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response

async def project_get(param_name: str = None) -> Dict[str, Any]:
    '''
    Get a project.

    Args:
        param_name (str, optional): OpenAPI parameter corresponding to 'param_name'. Defaults to None.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    '''
    logger.debug("Making GET request to /api/v1/projects/{name}")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    success, response = await make_api_request(f"/api/v1/projects/{param_name}", method="GET", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response

async def project_update(param_name: str = None) -> Dict[str, Any]:
    '''
    Update a project.

    Args:
        param_name (str, optional): OpenAPI parameter corresponding to 'param_name'. Defaults to None.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    '''
    logger.debug("Making PUT request to /api/v1/projects/{name}")

    params = {}
    data = {}

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    success, response = await make_api_request(f"/api/v1/projects/{param_name}", method="PUT", params=params, data=data)
    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response
