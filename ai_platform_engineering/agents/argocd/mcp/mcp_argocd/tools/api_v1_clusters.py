# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/clusters operations"""

import logging
from typing import Dict, Any, List
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("mcp_tools")


async def cluster_service__list(
    param_server: str = None, 
    param_name: str = None, 
    param_id_type: str = None, 
    param_id_value: str = None,
    summary_only: bool = True,
    page: int = 1,
    page_size: int = 20
) -> Dict[str, Any]:
    '''
    List returns a paginated list of clusters.

    Args:
        param_server (str, optional): Filter by cluster server URL. Defaults to None.
        param_name (str, optional): Filter by cluster name. Defaults to None.
        param_id_type (str, optional): Type of the specified cluster identifier ("server" - default, "name"). Defaults to None.
        param_id_value (str, optional): Value holds the cluster server URL or cluster name. Defaults to None.
        summary_only (bool, optional): If True, return only summary information (default: True).
        page (int, optional): Page number (1-indexed, default: 1).
        page_size (int, optional): Number of items per page (default: 20, max: 100).

    Returns:
        Dict[str, Any]: Paginated list of clusters with metadata:
        {
            "items": [...],
            "pagination": {
                "page": 1,
                "page_size": 20,
                "total_items": 15,
                "total_pages": 1,
                "has_next": false,
                "has_prev": false
            }
        }
    '''
    logger.debug("Making GET request to /api/v1/clusters")

    params = {}
    data = {}

    if param_server is not None:
        params["server"] = str(param_server).lower() if isinstance(param_server, bool) else param_server

    if param_name is not None:
        params["name"] = str(param_name).lower() if isinstance(param_name, bool) else param_name

    if param_id_type is not None:
        params["id_type"] = str(param_id_type).lower() if isinstance(param_id_type, bool) else param_id_type

    if param_id_value is not None:
        params["id_value"] = str(param_id_value).lower() if isinstance(param_id_value, bool) else param_id_value

    flat_body = {}
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/clusters", method="GET", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}

    # Enforce pagination limits
    page = max(1, page)
    page_size = min(100, max(1, page_size))

    all_items = response.get("items", [])
    total_items = len(all_items)
    total_pages = (total_items + page_size - 1) // page_size

    # Calculate pagination slice
    start_idx = (page - 1) * page_size
    end_idx = start_idx + page_size
    
    # Check if page is out of bounds
    if start_idx >= total_items and total_items > 0:
        return {
            "error": f"Page {page} out of bounds. Total pages: {total_pages}",
            "pagination": {
                "page": page,
                "page_size": page_size,
                "total_items": total_items,
                "total_pages": total_pages,
                "has_next": False,
                "has_prev": page > 1
            }
        }

    paginated_items = all_items[start_idx:end_idx]

    # Build pagination metadata
    pagination_meta = {
        "page": page,
        "page_size": page_size,
        "total_items": total_items,
        "total_pages": total_pages,
        "has_next": page < total_pages,
        "has_prev": page > 1,
        "showing_from": start_idx + 1 if paginated_items else 0,
        "showing_to": start_idx + len(paginated_items)
    }

    # If summary_only is True, return only essential information
    if summary_only:
        summary_items = []
        for cluster in paginated_items:
            summary_item = {
                "name": cluster.get("name", ""),
                "server": cluster.get("server", ""),
                "namespaces": cluster.get("namespaces", []),
                "cluster_resources": cluster.get("clusterResources", False),
                "project": cluster.get("project", ""),
                "labels": cluster.get("labels", {}),
                "annotations": cluster.get("annotations", {}),
                "shard": cluster.get("shard", ""),
                "server_version": cluster.get("info", {}).get("serverVersion", ""),
                "connection_status": cluster.get("info", {}).get("connectionState", {}).get("status", ""),
                "applications_count": cluster.get("info", {}).get("applicationsCount", 0),
            }
            summary_items.append(summary_item)

        return {
            "items": summary_items,
            "pagination": pagination_meta,
            "summary_only": True
        }

    return {
        "items": paginated_items,
        "pagination": pagination_meta
    }


async def cluster_service__create(
    body_annotations: Dict[str, Any] = None,
    body_clusterResources: bool = None,
    body_config_awsAuthConfig_clusterName: str = None,
    body_config_awsAuthConfig_profile: str = None,
    body_config_awsAuthConfig_roleARN: str = None,
    body_config_bearerToken: str = None,
    body_config_disableCompression: bool = None,
    body_config_execProviderConfig_apiVersion: str = None,
    body_config_execProviderConfig_args: List[str] = None,
    body_config_execProviderConfig_command: str = None,
    body_config_execProviderConfig_env: Dict[str, Any] = None,
    body_config_execProviderConfig_installHint: str = None,
    body_config_password: str = None,
    body_config_proxyUrl: str = None,
    body_config_tlsClientConfig_caData: str = None,
    body_config_tlsClientConfig_certData: str = None,
    body_config_tlsClientConfig_insecure: bool = None,
    body_config_tlsClientConfig_keyData: str = None,
    body_config_tlsClientConfig_serverName: str = None,
    body_config_username: str = None,
    body_connectionState_attemptedAt: str = None,
    body_connectionState_message: str = None,
    body_connectionState_status: str = None,
    body_info_apiVersions: List[str] = None,
    body_info_applicationsCount: int = None,
    body_info_cacheInfo_apisCount: int = None,
    body_info_cacheInfo_lastCacheSyncTime: str = None,
    body_info_cacheInfo_resourcesCount: int = None,
    body_info_connectionState_attemptedAt: str = None,
    body_info_connectionState_message: str = None,
    body_info_connectionState_status: str = None,
    body_info_serverVersion: str = None,
    body_labels: Dict[str, Any] = None,
    body_name: str = None,
    body_namespaces: List[str] = None,
    body_project: str = None,
    body_refreshRequestedAt: str = None,
    body_server: str = None,
    body_serverVersion: str = None,
    body_shard: int = None,
    param_upsert: bool = False,
) -> Dict[str, Any]:
    '''
    Create a cluster with the specified configuration.

    Args:
        body_annotations (Dict[str, Any], optional): Annotations for the cluster. Defaults to None.
        body_clusterResources (bool, optional): Indicates if cluster-level resources should be managed. Used only if the cluster is connected in a namespaced mode. Defaults to None.
        body_config_awsAuthConfig_clusterName (str, optional): The cluster name for AWS authentication configuration. Defaults to None.
        body_config_awsAuthConfig_profile (str, optional): Optional AWS profile for IAM Authenticator. Defaults to None.
        body_config_awsAuthConfig_roleARN (str, optional): Optional role ARN for AWS IAM Authenticator. Defaults to None.
        body_config_bearerToken (str, optional): Bearer token for server authentication. Defaults to None.
        body_config_disableCompression (bool, optional): If True, disables automatic GZip compression requests to the server. Defaults to None.
        body_config_execProviderConfig_apiVersion (str, optional): API version for exec provider configuration. Defaults to None.
        body_config_execProviderConfig_args (List[str], optional): Arguments for exec provider configuration. Defaults to None.
        body_config_execProviderConfig_command (str, optional): Command for exec provider configuration. Defaults to None.
        body_config_execProviderConfig_env (Dict[str, Any], optional): Environment variables for exec provider configuration. Defaults to None.
        body_config_execProviderConfig_installHint (str, optional): Installation hint for exec provider configuration. Defaults to None.
        body_config_password (str, optional): Password for server authentication. Defaults to None.
        body_config_proxyUrl (str, optional): Proxy URL for server connection. Defaults to None.
        body_config_tlsClientConfig_caData (str, optional): CA data for TLS client configuration. Defaults to None.
        body_config_tlsClientConfig_certData (str, optional): Certificate data for TLS client configuration. Defaults to None.
        body_config_tlsClientConfig_insecure (bool, optional): If True, access the server without verifying the TLS certificate. For testing only. Defaults to None.
        body_config_tlsClientConfig_keyData (str, optional): Key data for TLS client configuration. Defaults to None.
        body_config_tlsClientConfig_serverName (str, optional): Server name for SNI and certificate verification. Defaults to None.
        body_config_username (str, optional): Username for server authentication. Defaults to None.
        body_connectionState_attemptedAt (str, optional): Timestamp of the last connection attempt. Defaults to None.
        body_connectionState_message (str, optional): Message regarding the connection state. Defaults to None.
        body_connectionState_status (str, optional): Status of the connection state. Defaults to None.
        body_info_apiVersions (List[str], optional): Supported API versions. Defaults to None.
        body_info_applicationsCount (int, optional): Count of applications. Defaults to None.
        body_info_cacheInfo_apisCount (int, optional): Count of cached APIs. Defaults to None.
        body_info_cacheInfo_lastCacheSyncTime (str, optional): Timestamp of the last cache synchronization. Defaults to None.
        body_info_cacheInfo_resourcesCount (int, optional): Count of cached resources. Defaults to None.
        body_info_connectionState_attemptedAt (str, optional): Timestamp of the last connection state attempt. Defaults to None.
        body_info_connectionState_message (str, optional): Message regarding the connection state. Defaults to None.
        body_info_connectionState_status (str, optional): Status of the connection state. Defaults to None.
        body_info_serverVersion (str, optional): Server version information. Defaults to None.
        body_labels (Dict[str, Any], optional): Labels for the cluster. Defaults to None.
        body_name (str, optional): Name of the cluster. Defaults to None.
        body_namespaces (List[str], optional): List of accessible namespaces in the cluster. Defaults to None.
        body_project (str, optional): Project associated with the cluster. Defaults to None.
        body_refreshRequestedAt (str, optional): Timestamp when a refresh was requested. Defaults to None.
        body_server (str, optional): Server address. Defaults to None.
        body_serverVersion (str, optional): Version of the server. Defaults to None.
        body_shard (int, optional): Optional shard number. Defaults to None.
        param_upsert (bool, optional): If True, upsert the cluster configuration. Defaults to False.

    Returns:
        Dict[str, Any]: The JSON response from the API call.

    Raises:
        Exception: If the API request fails or returns an error.
    '''
    logger.debug("Making POST request to /api/v1/clusters")

    params = {}
    data = {}

    if param_upsert is not None:
        params["upsert"] = str(param_upsert).lower() if isinstance(param_upsert, bool) else param_upsert

    flat_body = {}
    if body_annotations is not None:
        flat_body["annotations"] = body_annotations
    if body_clusterResources is not None:
        flat_body["clusterResources"] = body_clusterResources
    if body_config_awsAuthConfig_clusterName is not None:
        flat_body["config_awsAuthConfig_clusterName"] = body_config_awsAuthConfig_clusterName
    if body_config_awsAuthConfig_profile is not None:
        flat_body["config_awsAuthConfig_profile"] = body_config_awsAuthConfig_profile
    if body_config_awsAuthConfig_roleARN is not None:
        flat_body["config_awsAuthConfig_roleARN"] = body_config_awsAuthConfig_roleARN
    if body_config_bearerToken is not None:
        flat_body["config_bearerToken"] = body_config_bearerToken
    if body_config_disableCompression is not None:
        flat_body["config_disableCompression"] = body_config_disableCompression
    if body_config_execProviderConfig_apiVersion is not None:
        flat_body["config_execProviderConfig_apiVersion"] = body_config_execProviderConfig_apiVersion
    if body_config_execProviderConfig_args is not None:
        flat_body["config_execProviderConfig_args"] = body_config_execProviderConfig_args
    if body_config_execProviderConfig_command is not None:
        flat_body["config_execProviderConfig_command"] = body_config_execProviderConfig_command
    if body_config_execProviderConfig_env is not None:
        flat_body["config_execProviderConfig_env"] = body_config_execProviderConfig_env
    if body_config_execProviderConfig_installHint is not None:
        flat_body["config_execProviderConfig_installHint"] = body_config_execProviderConfig_installHint
    if body_config_password is not None:
        flat_body["config_password"] = body_config_password
    if body_config_proxyUrl is not None:
        flat_body["config_proxyUrl"] = body_config_proxyUrl
    if body_config_tlsClientConfig_caData is not None:
        flat_body["config_tlsClientConfig_caData"] = body_config_tlsClientConfig_caData
    if body_config_tlsClientConfig_certData is not None:
        flat_body["config_tlsClientConfig_certData"] = body_config_tlsClientConfig_certData
    if body_config_tlsClientConfig_insecure is not None:
        flat_body["config_tlsClientConfig_insecure"] = body_config_tlsClientConfig_insecure
    if body_config_tlsClientConfig_keyData is not None:
        flat_body["config_tlsClientConfig_keyData"] = body_config_tlsClientConfig_keyData
    if body_config_tlsClientConfig_serverName is not None:
        flat_body["config_tlsClientConfig_serverName"] = body_config_tlsClientConfig_serverName
    if body_config_username is not None:
        flat_body["config_username"] = body_config_username
    if body_connectionState_attemptedAt is not None:
        flat_body["connectionState_attemptedAt"] = body_connectionState_attemptedAt
    if body_connectionState_message is not None:
        flat_body["connectionState_message"] = body_connectionState_message
    if body_connectionState_status is not None:
        flat_body["connectionState_status"] = body_connectionState_status
    if body_info_apiVersions is not None:
        flat_body["info_apiVersions"] = body_info_apiVersions
    if body_info_applicationsCount is not None:
        flat_body["info_applicationsCount"] = body_info_applicationsCount
    if body_info_cacheInfo_apisCount is not None:
        flat_body["info_cacheInfo_apisCount"] = body_info_cacheInfo_apisCount
    if body_info_cacheInfo_lastCacheSyncTime is not None:
        flat_body["info_cacheInfo_lastCacheSyncTime"] = body_info_cacheInfo_lastCacheSyncTime
    if body_info_cacheInfo_resourcesCount is not None:
        flat_body["info_cacheInfo_resourcesCount"] = body_info_cacheInfo_resourcesCount
    if body_info_connectionState_attemptedAt is not None:
        flat_body["info_connectionState_attemptedAt"] = body_info_connectionState_attemptedAt
    if body_info_connectionState_message is not None:
        flat_body["info_connectionState_message"] = body_info_connectionState_message
    if body_info_connectionState_status is not None:
        flat_body["info_connectionState_status"] = body_info_connectionState_status
    if body_info_serverVersion is not None:
        flat_body["info_serverVersion"] = body_info_serverVersion
    if body_labels is not None:
        flat_body["labels"] = body_labels
    if body_name is not None:
        flat_body["name"] = body_name
    if body_namespaces is not None:
        flat_body["namespaces"] = body_namespaces
    if body_project is not None:
        flat_body["project"] = body_project
    if body_refreshRequestedAt is not None:
        flat_body["refreshRequestedAt"] = body_refreshRequestedAt
    if body_server is not None:
        flat_body["server"] = body_server
    if body_serverVersion is not None:
        flat_body["serverVersion"] = body_serverVersion
    if body_shard is not None:
        flat_body["shard"] = body_shard
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/clusters", method="POST", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response