# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/applicationsets operations"""

import logging
from typing import Dict, Any, List
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("mcp_tools")


async def applicationset_list(
    param_projects: List[str] = None, 
    param_selector: str = None, 
    param_appsetNamespace: str = None, 
    summary_only: bool = True,
    page: int = 1,
    page_size: int = 20
) -> Dict[str, Any]:
    '''
    List returns a paginated list of applicationsets.

    Args:
        param_projects (List[str], optional): The project names to restrict the returned list of applicationsets. Defaults to None.
        param_selector (str, optional): The selector to restrict the returned list to applications only with matched labels. Defaults to None.
        param_appsetNamespace (str, optional): The application set namespace. If not provided, defaults to the ArgoCD control plane namespace. Defaults to None.
        summary_only (bool, optional): If True, return only summary information (default: True).
        page (int, optional): Page number (1-indexed, default: 1).
        page_size (int, optional): Number of items per page (default: 20, max: 100).

    Returns:
        Dict[str, Any]: Paginated list of applicationsets with metadata:
        {
            "items": [...],
            "pagination": {
                "page": 1,
                "page_size": 20,
                "total_items": 50,
                "total_pages": 3,
                "has_next": true,
                "has_prev": false
            }
        }
    '''
    logger.debug("Making GET request to /api/v1/applicationsets")

    params = {}
    data = {}

    if param_projects is not None:
        params["projects"] = str(param_projects).lower() if isinstance(param_projects, bool) else param_projects

    if param_selector is not None:
        params["selector"] = str(param_selector).lower() if isinstance(param_selector, bool) else param_selector

    if param_appsetNamespace is not None:
        params["appsetNamespace"] = (
            str(param_appsetNamespace).lower() if isinstance(param_appsetNamespace, bool) else param_appsetNamespace
        )

    flat_body = {}
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/applicationsets", method="GET", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}

    # Enforce pagination limits
    page = max(1, page)
    page_size = min(100, max(1, page_size))

    all_items = response.get("items", [])
    total_items = len(all_items)
    total_pages = (total_items + page_size - 1) // page_size

    # Calculate pagination slice
    start_idx = (page - 1) * page_size
    end_idx = start_idx + page_size
    
    # Check if page is out of bounds
    if start_idx >= total_items and total_items > 0:
        return {
            "error": f"Page {page} out of bounds. Total pages: {total_pages}",
            "pagination": {
                "page": page,
                "page_size": page_size,
                "total_items": total_items,
                "total_pages": total_pages,
                "has_next": False,
                "has_prev": page > 1
            }
        }

    paginated_items = all_items[start_idx:end_idx]

    # Build pagination metadata
    pagination_meta = {
        "page": page,
        "page_size": page_size,
        "total_items": total_items,
        "total_pages": total_pages,
        "has_next": page < total_pages,
        "has_prev": page > 1,
        "showing_from": start_idx + 1 if paginated_items else 0,
        "showing_to": start_idx + len(paginated_items)
    }

    # If summary_only is True, return only essential information
    if summary_only:
        summary_items = []
        for appset in paginated_items:
            summary_item = {
                "name": appset.get("metadata", {}).get("name", ""),
                "namespace": appset.get("metadata", {}).get("namespace", ""),
                "generation": appset.get("metadata", {}).get("generation", ""),
                "resource_version": appset.get("metadata", {}).get("resourceVersion", ""),
                "creation_timestamp": appset.get("metadata", {}).get("creationTimestamp", ""),
                "template_name": appset.get("spec", {}).get("template", {}).get("metadata", {}).get("name", ""),
                "template_namespace": appset.get("spec", {}).get("template", {}).get("spec", {}).get("destination", {}).get("namespace", ""),
                "template_project": appset.get("spec", {}).get("template", {}).get("spec", {}).get("project", ""),
                "template_repo": appset.get("spec", {}).get("template", {}).get("spec", {}).get("source", {}).get("repoURL", ""),
                "template_path": appset.get("spec", {}).get("template", {}).get("spec", {}).get("source", {}).get("path", ""),
                "template_target_revision": appset.get("spec", {}).get("template", {}).get("spec", {}).get("source", {}).get("targetRevision", ""),
                "generators_count": len(appset.get("spec", {}).get("generators", [])),
                "sync_policy": appset.get("spec", {}).get("syncPolicy", {}),
                "phase": appset.get("status", {}).get("phase", ""),
                "conditions": appset.get("status", {}).get("conditions", []),
            }
            summary_items.append(summary_item)

        return {
            "items": summary_items,
            "pagination": pagination_meta,
            "summary_only": True
        }

    return {
        "items": paginated_items,
        "pagination": pagination_meta
    }


async def applicationset_create(
    metadata_name: str,
    spec: Dict[str, Any],
    metadata_namespace: str = None,
    param_upsert: bool = False,
    param_dryRun: bool = False,
) -> Dict[str, Any]:
    """
    Create an application set.

    Args:
        metadata_name (str): Name of the ApplicationSet.
        spec (Dict[str, Any]): The spec for the ApplicationSet.
        metadata_namespace (str, optional): Namespace for the ApplicationSet.
        param_upsert (bool, optional): Upsert parameter. Defaults to False.
        param_dryRun (bool, optional): Dry run parameter. Defaults to False.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    """
    logger.debug("Making POST request to /api/v1/applicationsets")

    params = {}
    if param_upsert is not None:
        params["upsert"] = str(param_upsert).lower() if isinstance(param_upsert, bool) else param_upsert
    if param_dryRun is not None:
        params["dryRun"] = str(param_dryRun).lower() if isinstance(param_dryRun, bool) else param_dryRun

    body = {
        "metadata": {"name": metadata_name},
        "spec": spec,
    }
    if metadata_namespace:
        body["metadata"]["namespace"] = metadata_namespace

    success, response = await make_api_request("/api/v1/applicationsets", method="POST", params=params, data=body)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response