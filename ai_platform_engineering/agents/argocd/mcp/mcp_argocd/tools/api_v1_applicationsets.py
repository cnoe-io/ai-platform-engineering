# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api/v1/applicationsets operations"""

import logging
from typing import Dict, Any, List
from mcp_argocd.api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("mcp_tools")


async def applicationset_list(
    param_projects: List[str] = None, param_selector: str = None, param_appsetNamespace: str = None, summary_only: bool = True
) -> Dict[str, Any]:
    '''
    List returns a list of applicationsets.

    Args:
        param_projects (List[str], optional): The project names to restrict the returned list of applicationsets. Defaults to None.
        param_selector (str, optional): The selector to restrict the returned list to applications only with matched labels. Defaults to None.
        param_appsetNamespace (str, optional): The application set namespace. If not provided, defaults to the ArgoCD control plane namespace. Defaults to None.
        summary_only (bool, optional): If True, return only summary information (default: True).

    Returns:
        Dict[str, Any]: The JSON response from the API call containing the list of applicationsets.

    Raises:
        Exception: If the API request fails or returns an error.
    '''
    logger.debug("Making GET request to /api/v1/applicationsets")

    params = {}
    data = {}

    if param_projects is not None:
        params["projects"] = str(param_projects).lower() if isinstance(param_projects, bool) else param_projects

    if param_selector is not None:
        params["selector"] = str(param_selector).lower() if isinstance(param_selector, bool) else param_selector

    if param_appsetNamespace is not None:
        params["appsetNamespace"] = (
            str(param_appsetNamespace).lower() if isinstance(param_appsetNamespace, bool) else param_appsetNamespace
        )

    flat_body = {}
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request("/api/v1/applicationsets", method="GET", params=params, data=data)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}

    # If summary_only is True, return only essential information
    if summary_only and "items" in response:
        summary_items = []
        for appset in response["items"]:
            summary_item = {
                "name": appset.get("metadata", {}).get("name", ""),
                "namespace": appset.get("metadata", {}).get("namespace", ""),
                "generation": appset.get("metadata", {}).get("generation", ""),
                "resource_version": appset.get("metadata", {}).get("resourceVersion", ""),
                "creation_timestamp": appset.get("metadata", {}).get("creationTimestamp", ""),
                "template_name": appset.get("spec", {}).get("template", {}).get("metadata", {}).get("name", ""),
                "template_namespace": appset.get("spec", {}).get("template", {}).get("spec", {}).get("destination", {}).get("namespace", ""),
                "template_project": appset.get("spec", {}).get("template", {}).get("spec", {}).get("project", ""),
                "template_repo": appset.get("spec", {}).get("template", {}).get("spec", {}).get("source", {}).get("repoURL", ""),
                "template_path": appset.get("spec", {}).get("template", {}).get("spec", {}).get("source", {}).get("path", ""),
                "template_target_revision": appset.get("spec", {}).get("template", {}).get("spec", {}).get("source", {}).get("targetRevision", ""),
                "generators_count": len(appset.get("spec", {}).get("generators", [])),
                "sync_policy": appset.get("spec", {}).get("syncPolicy", {}),
                "phase": appset.get("status", {}).get("phase", ""),
                "conditions": appset.get("status", {}).get("conditions", []),
            }
            summary_items.append(summary_item)

        return {
            "items": summary_items,
            "total": response.get("total", len(summary_items)),
            "summary_only": True
        }

    return response


async def applicationset_create(
    metadata_name: str,
    spec: Dict[str, Any],
    metadata_namespace: str = None,
    param_upsert: bool = False,
    param_dryRun: bool = False,
) -> Dict[str, Any]:
    """
    Create an application set.

    Args:
        metadata_name (str): Name of the ApplicationSet.
        spec (Dict[str, Any]): The spec for the ApplicationSet.
        metadata_namespace (str, optional): Namespace for the ApplicationSet.
        param_upsert (bool, optional): Upsert parameter. Defaults to False.
        param_dryRun (bool, optional): Dry run parameter. Defaults to False.

    Returns:
        Dict[str, Any]: The JSON response from the API call.
    """
    logger.debug("Making POST request to /api/v1/applicationsets")

    params = {}
    if param_upsert is not None:
        params["upsert"] = str(param_upsert).lower() if isinstance(param_upsert, bool) else param_upsert
    if param_dryRun is not None:
        params["dryRun"] = str(param_dryRun).lower() if isinstance(param_dryRun, bool) else param_dryRun

    body = {
        "metadata": {"name": metadata_name},
        "spec": spec,
    }
    if metadata_namespace:
        body["metadata"]["namespace"] = metadata_namespace

    success, response = await make_api_request("/api/v1/applicationsets", method="POST", params=params, data=body)

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response