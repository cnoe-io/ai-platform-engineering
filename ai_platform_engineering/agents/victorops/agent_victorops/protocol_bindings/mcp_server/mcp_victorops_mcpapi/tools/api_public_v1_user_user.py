# Copyright 2025 CNOE
# SPDX-License-Identifier: Apache-2.0
# Generated by CNOE OpenAPI MCP Codegen tool

"""Tools for /api-public/v1/user/{user} operations"""

import logging
from typing import Dict, Any
from ..api.client import make_api_request, assemble_nested_body

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("mcp_tools")


async def get_api_public_v1_user_user(path_user: str) -> Dict[str, Any]:
    """
        Retrieve information for a user

        OpenAPI Description:
            Get the information for the specified user

    This API may be called a maximum of 2 times per second.


        Args:

            path_user (str): The VictorOps user to fetch


        Returns:
            Dict[str, Any]: The JSON response from the API call.

        Raises:
            Exception: If the API request fails or returns an error.
    """
    logger.debug("Making GET request to /api-public/v1/user/{user}")

    params = {}
    data = {}

    flat_body = {}
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request(
        f"/api-public/v1/user/{path_user}", method="GET", params=params, data=data
    )

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response


async def put_api_public_v1_user_user(
    path_user: str,
    body_firstName: str,
    body_lastName: str,
    body_username: str,
    body_email: str,
    body_admin: bool = None,
    body_expirationHours: float = None,
) -> Dict[str, Any]:
    """
        Update a user

        OpenAPI Description:
            Update the designated user

    This API may be called a maximum of 2 times per second.


        Args:

            path_user (str): The VictorOps user to be updated

            body_firstName (str): OpenAPI parameter corresponding to 'body_firstName'

            body_lastName (str): OpenAPI parameter corresponding to 'body_lastName'

            body_username (str): OpenAPI parameter corresponding to 'body_username'

            body_email (str): OpenAPI parameter corresponding to 'body_email'

            body_admin (bool): OpenAPI parameter corresponding to 'body_admin'

            body_expirationHours (float): The validity duration for the invitatation/set password link sent to the added user.


        Returns:
            Dict[str, Any]: The JSON response from the API call.

        Raises:
            Exception: If the API request fails or returns an error.
    """
    logger.debug("Making PUT request to /api-public/v1/user/{user}")

    params = {}
    data = {}

    flat_body = {}
    if body_firstName is not None:
        flat_body["firstName"] = body_firstName
    if body_lastName is not None:
        flat_body["lastName"] = body_lastName
    if body_username is not None:
        flat_body["username"] = body_username
    if body_email is not None:
        flat_body["email"] = body_email
    if body_admin is not None:
        flat_body["admin"] = body_admin
    if body_expirationHours is not None:
        flat_body["expirationHours"] = body_expirationHours
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request(
        f"/api-public/v1/user/{path_user}", method="PUT", params=params, data=data
    )

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response


async def delete_api_public_v1_user_user(
    path_user: str, body_replacement: str = None, body_replacementStrategy: str = None
) -> Dict[str, Any]:
    """
        Remove a user

        OpenAPI Description:
            Remove a user from your organization. You can choose a user to act as a replacement or let VictorOps handle finding the replacement. User will be replaced in their on-call rotations, escalation policies and scheduled overrides.

    This API may be called a maximum of 2 times per second.


        Args:

            path_user (str): The VictorOps user to be deleted

            body_replacement (str): The user to take the place of the deleted user in escalations

            body_replacementStrategy (str): The strategy you would like to use to replace the user. They work as follows specifiedUser - replace the deleted user with a specific user. If using
                   this strategy, you MUST provide the `replacement` field
                   as well. This is also the default strategy. So, if you
                   provide no replacementStrategy in your request, you are
                   still required to provide a `replacement` field.
    globalAdmin - replace the deleted user with the first Global Admin for the
                  organization.
    teamAdmin - replace the deleted user in rotations/escalation policies with
                the team admin for the team related to that rotation or escalation
                policy. This strategy REQUIRES that every team have an admin that
                is not the deleted user.
    findReplacement - This strategy will attempt to find the best replacement
                      based on roles within the team, paging policy configuration
                      and other factors. Selected replacement user will be
                      notified by email. You cannot delete the last active user on
                      any team or last Global Admin user using this strategy.



        Returns:
            Dict[str, Any]: The JSON response from the API call.

        Raises:
            Exception: If the API request fails or returns an error.
    """
    logger.debug("Making DELETE request to /api-public/v1/user/{user}")

    params = {}
    data = {}

    flat_body = {}
    if body_replacement is not None:
        flat_body["replacement"] = body_replacement
    if body_replacementStrategy is not None:
        flat_body["replacementStrategy"] = body_replacementStrategy
    data = assemble_nested_body(flat_body)

    success, response = await make_api_request(
        f"/api-public/v1/user/{path_user}", method="DELETE", params=params, data=data
    )

    if not success:
        logger.error(f"Request failed: {response.get('error')}")
        return {"error": response.get("error", "Request failed")}
    return response
