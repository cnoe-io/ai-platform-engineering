apiclarity.io website documentation
¶
ð SRE team does
NOT
manage apiclarity.io anymore
¶
Table of Contents
¶
ð SRE team does
NOT
manage apiclarity.io anymore
Intro
Quick Links
Solution Architecture
Cloud Architecture
Traffic Routing
Dev
Production / Staging
Environments
Workflows
Monitoring
More Information
Deployment Architecture
Blue-Green Deploy Automation
Intro
¶
This page describes the deployment architecture for
apiclarity.io
, the official website for the APIClarity open source project. The APIClarity project provides API traffic visibility in K8s clusters.
Quick Links
¶
Deployed Urls:
Dev:
https://api-clarity.int.dev.apiclarity.io
(requires VPN)
Staging:
https://staging.apiclarity.io
Prod:
https://apiclarity.io
Source Code Repo
Deployment Repo
Development Workflow: See
Basic Workflows
Build Job
Deploy Jobs
ArgoCD:
Dev
Staging
Prod
Solution Architecture
¶
apiclarity.io is deployed to
ETI SRE shared K8s clusters
Cloud Architecture
¶
Traffic Routing
¶
Dev
¶
The application endpoint for development is pointed directly at the Kubernetes Ingress proxy. This proxy restricts access to Cisco network CIDRS, so users must be on VPN for access.
Production / Staging
¶
The application endpoints for production and staging are pointed at CloudFront, which is configured for
origin failover
for high availability.
Environments
¶
Dev -> Staging -> Prod
Dev
Staging
Prod
Blue-Green Application Upgrades
no
yes
yes
HA (deployed to 2+ distinct K8s clusters)
no
yes
yes
CloudFront
no
yes
yes
Workflows
¶
See the
basic workflows
in the
CI/CD in ETI
page to understand the development workflow.
To learn how to leverage the build and deploy jobs to push changes out to the dev environment and promote those changes to staging/prod, see the
Tutorial - Invoking Jenkins Build and Deploy jobs
section
here
.
Monitoring
¶
TBD
[TODO: update with blackbox monitoring links]
More Information
¶
Deployment Architecture
¶
The diagram above shows how the source code and deployment repositories are linked to CI/CD GitOps
workflows
described above. In accordance with the
"build, release, run" principle
, Continuous Integration (i.e, "build" stage) is decoupled from Continuous Deployment (i.e., "release" phase). The build jobs build immutable artifacts (application docker image / helm chart) and publishes them to their respective  repositories under new tags, after which the job ends. It is only when a separate deploy job gets triggered with the new version/tag that the published artifact gets released to any environment.
Blue-Green Deploy Automation
¶
The diagram above shows how the logical blue/green "color version" labels enable controlled application upgrades. A new version of the application are pushed to the "inactive" color version while end-user traffic continues to be served by the opposite "active" color version. Once the new changes are deemed to be safe (e.g., via application health checks), routing changes are made to toggle the active/inactive color version mapping.
For high-availability, both blue and green versions of the application are deployed to distinct Kubernetes clusters (referred to as logical K8s clusters "a" and "b").
2022-05-18