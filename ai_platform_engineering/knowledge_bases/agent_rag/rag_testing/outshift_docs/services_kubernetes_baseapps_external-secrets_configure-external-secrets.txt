ESO
configure external secrets
How-to configure external-secrets
¶
There are two ways to configure external secrets for k8s clusters
Preferred for all EKS clusters
:
Keeper can reach K8s API Endpoint:
Use
Vault k8s auth engine
with mutual authentication setup using
external-secrets service token
.
This setup
doesn't
require periodic vault token renewal.
Temporary vault tokens are issued to external-secrets operator.
Cluster flavors to use this method on
: EKS
Keeper cannot reach K8s API Endpoint:
Use Vault Orphan token with 30 day expiry.
Renew the token every 30 days manually/with automation.
Cluster flavors to use this method on:
P3, GCP, VMWare Tanzu, etc.
Keeper can reach k8s API Endpoint: Vault K8s Engine
¶
Setup ESO configuration via terraform (Preferred)
¶
When using
platform-terraform-infra
repository, you will utilize the
eso-access
module to provision Kubernetes authentication to the Vault backend for your cluster.
There are few parameters that should be provided:
Tip
If your cluster need access to multiple namespaces, please call this module according to the convention used for instantiating the module, which is
eso_<namespace>
.
Note
If you encounter errors with your
clustersecretstore
resources, ensure that you have instantiated the eso module for each
clustersecretstore
and that the policy environment (dev, staging, prod) matches the environment you are configuring external secrets in.
Here is the example for the
eticloud
namespace:
¶
module "eso_eticloud" {
source               = "git::https://wwwin-github.cisco.com/eti/sre-tf-module-eso-access.git?ref=0.0.2"
cluster_name         =  var.eks_name
vault_namespace      = "eticloud"
kubernetes_host      = data.aws_eks_cluster.cluster.endpoint
kubernetes_ca        = base64decode(data.vault_generic_secret.cluster_certificate.data["b64certificate"])
policies             = [ "external-secrets-prod-scs"]
}
-
cluster name
- based on it, this module created in the required Vault namespace
vault-namespace
- The namespace you want to grant access to your k8s cluster
policies
- you have to provide list of policies that are allowed to connect to a particular namespace (with the legacy way we used an unified policy for everyone, we recommend to create a dedicated policy per cluster via
platform-terraform-infra
for recent clusters/policies.
Be aware
that role names are changed too and now have a convention: external-secrets-\<cluster name>, you will need this role name once you are configuring your base app per cluster
serviceAccountName: external-secrets-vault
external-secrets:
installCRDs: true
serviceMonitor:
enabled: false
secretstores:
- name: vault-eticloud
kind: ClusterSecretStore
namespace: external-secrets
vault:
server: "https://keeper.cisco.com"
path: "secret"
namespace: "eticloud"
version: "v2"
kubernetes:
mountPath: "<cluster-name>"
role: "external-secrets-<cluster-name>"
serviceAccountRef:
name: "external-secrets-vault"
namespace: "external-secrets"
Setup ESO with legacy script (semi-manual)
¶
Pre-requisite:
Setup kubectl/kubeconfig access to the
target
cluster
or or
K8s Shell helper
Vault Token
You will need yq
Mac install
brew install yq
Note
yq version should be atleast
v4.34.2
â¯ yq -V
yq (
https://github.com/mikefarah/yq/
) version v4.34.2
You will need jq
Mac install
brew install jq
Note
jq version should be atleast
v1.6
â¯ jq --version
jq-1.6
Clone sre-utilties repo
git
clone
git@github.com:cisco-eti/sre-utilities.git
Change directory to argocd utils
cd
sre-utilities/scripts/argocd
Export your vault token
export
VAULT_TOKEN
=
<SPECIFY_YOUR_VAULT_TOKEN>
Export Vault address
export
VAULT_ADDR
=
https://keeper.cisco.com
Export vault namespace
export
VAULT_NAMESPACE
=
eticloud
Note
SRE team will use
vault_admin
to login using vault cli sso login
export
VAULT_TOKEN
=
$(
vault
login
-method
=
oidc
-format
=
json
|
jq
-r
.auth.client_token
)
Run the shell script that configures external-secrets.
Specify the name of the cluster
cluster_name
should match
the eks cluster name
bash
argocd_external_secrets.sh
<cluster_name>
Tip
Example:
./argocd_external_secrets.sh eks-sre-1
Note
The script will now automatically retrieve the namespaces required by the external-secrets controller and process each of them one at a time.
bash
argocd_external_secrets.sh
<Cluster
Name>
Sample Output
:
â¯
bash
argocd_external_secrets.sh
baseapps-test-1
CLUSTER_ENVIRONMENT
was
NOT
specified.
Using
'dev'
Granting
To:
eticloud
Success!
Data
written
to:
auth/baseapps-test-1/config
Success!
Data
written
to:
auth/baseapps-test-1/role/external-secrets-dev
Success!
Uploaded
policy:
external-secrets-dev
Success!
Uploaded
policy:
external-secrets-dev
{
"request_id"
:
"c27017e6-d1fb-2be8-e487-8b5676ef6671"
,
"lease_id"
:
""
,
"renewable"
:false,
"lease_duration"
:0,
"data"
:null,
"wrap_info"
:null,
"warnings"
:null,
"auth"
:
{
"client_token"
:
"REDACTED"
,
"accessor"
:
"REDACTED"
,
"policies"
:
[
"default"
,
"external-secrets-dev"
]
,
"token_policies"
:
[
"default"
,
"external-secrets-dev"
]
,
"metadata"
:
{
"role"
:
"external-secrets-dev"
,
"service_account_name"
:
"external-secrets-vault"
,
"service_account_namespace"
:
"external-secrets"
,
"service_account_secret_name"
:
"external-secrets-vault-secret"
,
"service_account_uid"
:
"aa1e5530-2d55-4a28-8b88-694bfe083268"
}
,
"lease_duration"
:3600,
"renewable"
:true,
"entity_id"
:
"62e6690a-e91d-3422-290e-e84f972de287"
,
"token_type"
:
"service"
,
"orphan"
:true,
"mfa_requirement"
:null,
"num_uses"
:0
}}
Tip
Example:
./argocd_external_secrets.sh eks-sre-1
2. Verify that external secrets are working
¶
Verify Clustersecretstore is valid
¶
kubectl
get
clustersecretstores.external-secrets.io
-A
Sample Output:
â¯
kubectl
get
clustersecretstores.external-secrets.io
-A
NAME
AGE
STATUS
READY
vault-eticloud
43h
Valid
True
Verify Externalsecrets are valid
¶
kubectl
get
externalsecrets.external-secrets.io
-A
Sample Output:
â¯
kubectl
get
externalsecrets.external-secrets.io
-A
NAMESPACE
NAME
STORE
REFRESH
INTERVAL
STATUS
READY
external-secrets
eticloud-access-test
vault-eticloud
1h0m0s
SecretSynced
True
Detailed explanation of the workflow using a sequence diagram
¶
Keeper
cannot
reach k8s API endpoint: Vault Token
¶
Tip
For update already created and expired Vault Tokens (for example on some GKE cluster) use this automation
script
Be sure that you have VAULT_TOKEN variable and right context for needed kubernetes cluster.
Script will find alredy defined secrets (with names "vault-token*") and based on the names of the secrets will get new tokens for needed namespaces, store new tokens and restart external secrets main pod for pushing those changes
Token Renewal
¶
git
clone
https://github.com/cisco-eti/sre-utilities.git
cd
sre-utilities/scripts/argocd
./argocd_external_secrets_gke_token_update.sh
First time setup
¶
Setup target cluster variable
TARGET_CLUSTER
=
eks-prod-3
Setup Vault variables
export
VAULT_TOKEN
=
$(
vault
login
-method
=
oidc
-format
=
json
|
jq
-r
.auth.client_token
)
export
VAULT_ADDR
=
https://keeper.cisco.com
export
VAULT_NAMESPACE
=
<SPECIFY_DESIRED_VAULT_NAMESPACE>
Create vault policy if it doesn't exist
Tip
â­ï¸ Skip this step for token renewal
vault
policy
write
external-secrets
-
<< EOF
# K8s External Secrets Vault Policy
path "secret/*" {
capabilities = ["read", "list"]
}
EOF
Switch Kubernetes context
kubectl
config
use-context
$TARGET_CLUSTER
Create namespace if it doesn't exist
Tip
â­ï¸ Skip this step for token renewal
kubectl
create
ns
external-secrets
Create vault orphan token with external-secrets policy
Note
â¼ï¸ Important step for token renewal â¼ï¸
NEW_ORPHAN_TOKEN
=
$(
VAULT_TOKEN
=
$VAULT_TOKEN
VAULT_NAMESPACE
=
$VAULT_NAMESPACE
vault
token
create
-policy
=
external-secrets
-ttl
=
768h
-orphan
-format
=
json
|
jq
-r
'.auth.client_token'
)
&&
kubectl
delete
secret
vault-token
-n
external-secrets
--ignore-not-found
&&
kubectl
create
secret
generic
vault-token
--from-literal
=
vault-token
=
$NEW_ORPHAN_TOKEN
-n
external-secrets
â¡ï¸âto "How does secret retrieval using External Secrets Operator (ESO) work? (Web sequence diagram)"
2024-09-26