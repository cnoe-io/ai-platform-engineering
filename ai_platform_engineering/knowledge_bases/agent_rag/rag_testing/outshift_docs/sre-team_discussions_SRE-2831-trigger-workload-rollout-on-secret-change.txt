Trigger workload rollout on secret change
¶
Problem
¶
Kubernetes workloads (Deployment, StatefulSet, etc) often rely on ConfigMaps and Secrets to inject additional information into containers.
Container can read these inputs as:
- Files (read on startup)
- Environment variables (env, envFrom, etc)
Secret and configuration management improved a lot over the years. As a result, changing these inputs does not necessarily require triggering an entire deployment pipeline anymore. For example, secrets can be synchronized from external secret stores by using something like External Secrets. Or ConfigMaps could be synchronized from git repositories (GitOps).
Back in the "old days" (and actually these days with Kustomize) there were two general strategies for reflecting changes in ConfigMaps and Secrets:
- When using Helm, the workload templates would contain a checksum generated from ConfigMap/Secret templates
- Kustomize generates new ConfigMaps/Secrets on every change
But again, these strategies require triggering an entire deployment pipeline. Since ConfigMap/Secret changes no longer require that, we need a solution that works without triggering deployments.
The most straightforward solution is triggering a normal rollout whenever a ConfigMap or a Secret changes. That would restart each container causing files and environment variables to be read again. This is not strictly necessary for applications that watches files for changes (because changes are actually propagated to containers), but the majority of applications are not capable of that (and for good reason: safely reloading an application with all of its external dependencies is not trivial).
The manual approach
¶
When ConfigMaps/Secrets are changed manually, a manual rollout can be triggered with the following command:
kubectl
rollout
restart
deploy
DEPLOYMENT_NAME
This will trigger a normal rollout flow (by changing an annotation on the workload) according to the rollout configuration for the workload and any PodDistruptionBudget that may match the underlying pods. This is important in order to avoid any downtime during the rollout. It also works well with ArgoCD like CD solutions, because they usually don't care about additional annotations.
Some people tend to "restart applications" by deleting all pods. Although that works, it can easily cause downtime.
The above approach can be scripted and automated if necessary, but sadly it doesn't work in scenarios where changes are already propagated to ConfigMaps/Secrets (eg. GitOps or Hashicorp Vault backend secrets synchronized to Kubernetes).
The automatic approach
¶
When ConfigMap/Secret updates themselves are automated (eg. GitOps, ESO), the more practical solution is automatically detecting that change from within the cluster and triggering a rollout flow (as explained above).
There are several different ways to track changes in ConfigMaps/Secrets, but the most Kubernetes-native one is subscribing to events using the Kubernetes API. Such controller would listen to changes of ConfigMaps/Secrets that are referenced from a workload. When something changes, the controller would update something in the workload (eg. an annotation, similar to kubectl).
Meet Reloader
¶
https://github.com/stakater/Reloader
Although secret and configuration management improved a lot over the years, this problem is still not widely solved in the community.
Reloader is not the only, but probably the most advanced tool out there the implements the above idea: it comes with a controller that listens to changes and annotates the workload when something changes.
It has a bunch of configuration options and modes of operation:
There is an auto mode that tries to automagically figure out everything. Haven't tried it, but magic is...scary.
The search-match mode requires annotating both workloads and ConfigMaps/Secrets: rollout will be triggered for annotated workloads with annotated ConfigMaps/Secrets.
Alternatively, you can explicitly list which ConfigMaps/Secrets should trigger a reload.
Where this solution falls short
¶
The above solution only works with workloads (Deployments, StatefulSets, etc) and ConfigMaps/Secrets. Unfortunately (or not), we live in the world of operators and CRs, so even though input might originally come from a Secret, if a CR needs some parts of the Secret in its own spec, updating the secret will continue to be a manual task.
For example, Harbor (operator) requires the S3 access key for the registry backend to be passed in a CR.
See
https://github.com/goharbor/harbor-operator/issues/843
2023-08-25