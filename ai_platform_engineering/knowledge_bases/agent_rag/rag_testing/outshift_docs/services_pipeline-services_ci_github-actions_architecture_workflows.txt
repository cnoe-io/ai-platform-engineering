github actions marketplace
github actions workflows jobs
Github Actions Workflows
¶
A workflow in Github Actions is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file in the target repository and will run when triggered by an event in the repository, or can also be triggered manually, or at a defined schedule.
Basic Workflows
¶
A basic workflow is a yaml file defined in a directory named .github/workflows
It doesn't have any dependencies
Example yaml:
name
:
basic-github-actions
run-name
:
${{ github.actor }} basic github action
on
:
# Run this basic workflow on a push event to 'main' branch
push
:
branches
:
-
'main'
jobs
:
checkout-code
:
runs-on
:
ubuntu-latest
steps
:
-
name
:
Checkout repository
uses
:
actions/checkout@3
with
:
repository
:
github.com/cisco-eti/sre-go-helloworld
ref
:
main
token
:
${{ secrets.ghcr-org-token }}
Reusable Workflows
¶
Reusable workflows
are created to enable CI code sharing across various Outhift products. This will also avoid copying and pasting workflows across multiple Outshift repositories.
SRE team implemented a reference
reusable workflow
to match the various stages in Jenkins
sre-pipeline-library
along with reference
helloworld implementation
References:
sre-reusable-workflows
sre-go-helloworld
Required Workflows
¶
Required workflows
define and enforce standard CI/CD practices across many source code repositories within an organization without needing to configure each repository individually.
References:
sre-required-workflows
All required workflows are defined inside
.github/workflows
folder (by convention). These required workflows are a
subset
of all reusable workflows, which are implemented in the
gh-reusable-workflows
repository.
Note
The required workflows are defined in the
gh-required-workflows
repo.
point to the actual implementation for those workflows in the
gh-reusable-workflows
repository.
At the time of writing this doc, we have defined the follow required workflows:
Inclusive lint: commun required workflow for all repositories
Sonar scan: will be enabled/disabled it depends on your needs
See the
gh-required-workflows/.github/worklows/
for a current list of all required workflows.
Below example:
name
:
Sonar Scan
on
:
# for now, required workflows support only triggers from pull requests
workflow_dispatch
:
pull_request
:
branches
:
-
'main'
jobs
:
call-sonar-scan
:
name
:
Sonar Scan
uses
:
cisco-eti/gh-reusable-workflows/.github/workflows/sonar-scan.yaml@SRE-5436
secrets
:
vault-approle-role-id
:
${{ secrets.VAULT_APPROLE_ROLE_ID }}
vault-approle-secret-id
:
${{ secrets.VAULT_APPROLE_SECRET_ID }}
These workflows will be configured to run on each pull request opened on some repository (already defined), and the PR will be blocked until all required workflows run successfully.
To add new required workflow, please select "Actions" tab, then choose "General" and scroll down until Required workflows section, click on "Add required workflow button" and select path to required workflow file and on which repository it will be executed as shown on scrennshot:
Reusable workflows
¶
Reusable workflows are similar to jenkins shared library, templates that can be called on any repository. All reusable workflows are defined inside
.github/workflows
folder (mandatory location). For now, we defined below templates:
Pre-build jobs:
Inclusive lint
Sonar scan
Build jobs:
- go-build
- build-push-docker AWS GHCR, ECR, GCR and GAR
Requirements:
¶
AWS ECR Authentification
¶
We have configured OpenID connect in order to push to AWS ECR, more details
How to configure
For now, we created via AWS console:
New Identity provider for Github actions
GHA Identity provider
Then IAM role in order to allow all our cisco-eti repository push docker image to AWS ECR (we can after restrict for some repository)
IAM Role
To link Identity provider and this role, we updated "Trust relationships" section
more details
GAR Authentification
¶
To push to GAR, we should configure GHA and GAR authentification, please refer to this doc
for more details
For now, we created
service account for github action named github-actions
GHA Serevice account
Generate key by selecting the created service account, choose "Keys" Tab and click on "Add key" bottom
Add key
Add this token to keeper
Allow this service account to push to GAR: go to Artifact Registry, then select the appropriate repository to add permissions, then add your service account on the right pannel by clicking on "Add Principal"
add permissions
GCR Authentification
¶
We are using same credentials used on jenkins, they are stored on
vault
Post-build jobs:
- corona-blackduck-scan
- panoptica-scan
- helm-deploy
See
gh-reusable-workflows
for a current list of all available reusable workflows.
example:
---
name
:
Inclusive Lint
on
:
# REUSABLE WORKFLOW with INPUTS
workflow_call
:
# allow reuse of this workflow in other repos
jobs
:
build-image
:
name
:
Inclusive Lint
runs-on
:
${{ vars.RUNNER_LABEL }}
container
:
image
:
${{ vars.SRE_PIPELINE_DOCKER_IMAGE }}
options
:
--user ubuntu
env
:
IMAGE_NAME
:
${{ inputs.image-name }}
steps
:
-
name
:
Figlet
run
:
|
figlet -w 140 'INCLUSIVE LINT' || true
shell
:
bash
-
name
:
woke
# Use shell command instead of unverified action
run
:
|
set -e
woke --version
cat woke/rules.yaml
woke -c woke/rules.yaml . --output pushgateway > inclusive.output
cat inclusive.output
if [ -s inclusive.output ]
then
echo "WARNING you've got non inclusive terms"
else
echo "You're good with inclusive checks"
fi
shell
:
bash
Application repository (call workflows)
¶
sre-go-helloworld is an example of workflows caller repository. We should define our CI/CD workflow inside .github/workflows folder. We could call reusable workflows or define custom jobs with cutom actions or call actions from github marketplace.
Below example of CI workflow:
name
:
Reusable workflow CI/CD
on
:
# we want pull requests so we can build(test) but not push to image registry
push
:
branches
:
-
'main'
pull_request
:
branches
:
-
'main'
workflow_dispatch
:
# Grant read access for GITHUB_TOKEN on all jobs
permissions
:
id-token
:
write
# This is required for requesting the JWT
contents
:
read
# This is required for actions/checkout
packages
:
write
# needed to push docker image to gar or ecr
jobs
:
################################## checkout ###################################
###############################################################################
checkout
:
name
:
checkout
runs-on
:
${{ vars.RUNNER_LABEL }}
container
:
image
:
${{ vars.SRE_PIPELINE_DOCKER_IMAGE }}
steps
:
-
name
:
Checkout repository
uses
:
actions/checkout@83b7061638ee4956cf7545a6f7efe594e5ad0247
# v3.5.1
with
:
# The branch, tag or SHA to checkout, otherwise, uses the default branch.
ref
:
${{ github.ref }}
################################## Unit Test ###################################
#################################################################################
unit-test
:
name
:
Unit Tests
runs-on
:
${{ vars.RUNNER_LABEL }}
needs
:
[
checkout
]
container
:
${{ vars.SRE_PIPELINE_DOCKER_IMAGE }}
steps
:
-
name
:
Run Unit Test
run
:
bash scripts/unit-test.sh
################################## Docker build & push ##########################
#################################################################################
call-docker-build-push
:
name
:
Call Docker Build
needs
:
[
call-go-build-test
]
uses
:
cisco-eti/gh-reusable-workflows/.github/workflows/build-push-docker.yaml@main
secrets
:
# Only needed if with:ecr-enabled or with:gar-enabled is true below
vault-approle-role-id
:
${{ secrets.VAULT_APPROLE_ROLE_ID }}
vault-approle-secret-id
:
${{ secrets.VAULT_APPROLE_SECRET_ID }}
ghcr-username
:
${{ secrets.GHCR_USERNAME }}
ghcr-token
:
${{ secrets.GHCR_TOKEN }}
with
:
### REQUIRED
### Docker image name
image-name
:
${{ github.event.repository.name }}
### path to where docker should copy files into image
### defaults to root of repository (.)
# context: .
### Dockerfile alternate name. Default is Dockerfile (relative to context path)
dockerfile
:
docker/Dockerfile
setup-go
:
true
### REQUIRED
### ENABLE ONE OR MORE REGISTRIES
### tell docker where to push.
ecr-enabled
:
false
gcr-enabled
:
false
gar-enabled
:
false
ghcr-enabled
:
true
ghcr-org-registry
:
${{ vars.GHCR_REGISTRY }}
################################## Panoptica scan ###############################
#################################################################################
call-panoptica-scan
:
name
:
Call Panoptica scan
needs
:
[
call-docker-build-push
]
uses
:
cisco-eti/gh-reusable-workflows/.github/workflows/panoptica-scan.yaml@main
with
:
runner
:
${{ vars.UBUNTU_RUNNER }}
runner-docker-image
:
${{ vars.SRE_PYTHON_IMAGE }}
panoptica-scan-args
:
"--highest-severity-allowed
High
--ignore-no-fix
--ignore-vul
GHSA-r9hx-vwmv-q579"
### optional args
#image-name: ""
#image-tag: ""
secrets
:
# GHCR Login for docker build runner
ghcr-username
:
${{ secrets.GHCR_USERNAME }}
ghcr-token
:
${{ secrets.GHCR_TOKEN }}
# GHCR Login for docker scan
ghcr-org-username
:
${{ secrets.GHCR_USERNAME }}
ghcr-org-token
:
${{ secrets.GHCR_TOKEN }}
vault-approle-role-id
:
${{ secrets.VAULT_APPROLE_ROLE_ID }}
vault-approle-secret-id
:
${{ secrets.VAULT_APPROLE_SECRET_ID }}
################################## Corona & blackduck scan ######################
#################################################################################
call-corona-blackduck-scan
:
name
:
Call Corona & Blackduck scan
needs
:
[
call-docker-build-push
]
uses
:
cisco-eti/gh-reusable-workflows/.github/workflows/corona-blackduck-scan.yaml@main
with
:
runner
:
${{ vars.UBUNTU_RUNNER }}
runner-docker-image
:
${{ vars.SRE_PYTHON_IMAGE }}
corona-product-name
:
${{ vars.CORONA_SECURECN_PRODUCT_NAME }}
corona-product-id
:
${{ vars.CORONA_SECURECN_PRODUCT_ID }}
corona-release-id
:
${{ vars.CORONA_SECURECN_RELEASE_ID }}
corona-csdl-id
:
${{ vars.CORONA_SECURECN_CSDL_ID }}
corona-security-contact
:
${{ vars.CORONA_SECURITY_CONTACT }}
corona-engineering-contact
:
${{ vars.CORONA_ENGINEERING_CONTACT }}
corona-image-admins
:
${{ vars.CORONA_IMAGE_ADMINS }}
ghcr-org-registry
:
${{ vars.GHCR_REGISTRY }}
# optional
#image-name: ""
#image-tag: ""
secrets
:
vault-approle-role-id
:
${{ secrets.VAULT_APPROLE_ROLE_ID }}
vault-approle-secret-id
:
${{ secrets.VAULT_APPROLE_SECRET_ID }}
# GHCR Login for docker build runner
ghcr-username
:
${{ secrets.GHCR_USERNAME }}
ghcr-token
:
${{ secrets.GHCR_TOKEN }}
# GHCR Login for docker scan
ghcr-org-username
:
${{ secrets.GHCR_USERNAME }}
ghcr-org-token
:
${{ secrets.GHCR_TOKEN }}
Let's see what has been defined on this file. To keep it simple, we have two main section on the workflow:
"On" where we define "Events" which are workflow triggers. In our case workflow will be triggered on each commit & push on main branch, each time we create pull request on main branch. We could execute manually ths workflow as we have defined "workflow_dispatch" option.
"jobs" where we define tasks implementation.
This workflow contains 5 jobs wich will run sequentially as we have defined "needs" on each job (by default all jobs will run in parallel mode). It will be executed on self hosted runner by selecting machines with label  ${{ vars.RUNNER_LABEL }}.
As you can see RUNNER_LABEL is a variable. We can define it inside
- repository
- or organisation level if they are common to some repositories
In our case it has been defined on organisation level.
In this workflow, there are two custom jobs "checkout" and "unit-tests" that have been defined here and three jobs that call reusable workflows (defined on "gh-reusable-workflows" repository).
When we call workflow, we should define values for required parameters on the "with" section.
We can even override secrets on "secrets" section.
In our case, we integrated Vault Approle with github in order to get secrets from Keeper using predefined github action "vault-action". For more details, please see:
Vault-action
Setup Vault Approle auth
2023-09-21