vault gcp qsecrets engine
Creating and using an GCP Secrets Engine in Vault
¶
Purpose
¶
This document describes the resources required for the creation of an GCP Secrets Engine (GCPSE), the functions and relationships of those resources, and the most common use cases for an GCPSE.
Required Resources
¶
Note that the resources described below are the primary actors in GCPSE usage. The example links below point to files which have the complete codified definitions of both the actors and functional resources. Upon multiple iterations of GCPSE usage, it was decided to use the
access_token
togehter with
rolesets
method, instead of using
service_account_key
and
service_account_key_file
methods. The
service_account_key
and
service_account_key_file
methods are still available for use, but are not recommended as they are limited to 10 keys per service account (this is problematic when having multiple/parallel pipelines). For more information, please refer to the
official Hashicorp documentation
.
Vault Resources
¶
GCP Secrets Engine
Backend Roleset(s)
GCP Resources
¶
IAM Service Account
IAM Policy Attachment(s)
IAM Roleset(s)/Service Account(s) + Binding(s)
Creating an GCP Secrets Engine
¶
Creating GCP Resources
¶
An GCP Secrets Engine in Vault is dependent on GCP IAM resources. We create the GCP resources via Terraform in the
platform-terraform-infra
.
The current agreed upon folder structure for Secrets Engines is:
namespaces
| __ eticloud
| __ apps
| __ <namespace/venture name>
| __ backend.tf/main.tf/provider.tf - namespace infra
| __ approles
| __ secrets-engines
|__ <Cloud Provider>
| __ <Cloud Account/Project name>
| __ backend.tf/iam.tf/main.tf/provider.tf - secret engine's approle/IAM role binding infra
GCP IAM Service Account
¶
The GCP IAM Service Account:
    - Is created specifically for the Vault GCP secrets engine.
    - Can only assume roleset(s) and create service account(s) + access key(s) (JSON) (these are only created once and used by the backend integration for
access_token
creation) for the defined roleset(s).
    - A basic IAM policy needs to be bound to the service account, in order to be able to create service account.
The service account key (JSON) is created, but not stored in Keeper. It is directly injected into the required Vault GCP secrets engine.
Example 1
Example 2
GCP IAM Policy/Role Attachment(s)
¶
A minimum of one IAM basic policy needs to be created. It can be assigned to either a user or another active service account and needs to have the
roles/iam.serviceAccountUser
permission, for more information please refer to the
official GCP Terraform Provider module
. The other default policies for the created service account are automatically inherited in GCP. In addition the service account needs to have the
roles/editor
and
roles/iam.securityAdmin
roles bound to it, in order to be able to create service accounts and access keys (JSON) for the defined roleset(s).
IAM User policy
IAM Role Membership
Creating Vault Resources
¶
Create the Secrets Engine in the namespace.
Example
Note
The Secrets Engine uses the IAM Service Account credentials
above
.
Create the backend Roleset(s) assignment.
Example
Note
These GCP Roleset(s) determine the type of service account credentials granted (assumed service accounts) and specifies what those assumed role(s) permissions are in GCP.
Warning
We should only use the
access_token
secret type when creating the backend roleset(s) assignment for CI systems/processes, as the
service_account_key
and
service_account_key_file
methods are limited to 10 keys per service account (this is problematic when having multiple/parallel CI pipelines). For more information, please refer to the
official Hashicorp documentation
.
Using an GCP Secrets Engine
¶
Using an GCP Secrets Engine in Vault allows programmatic access to GCP resources using short lived access tokens.
GCP Secrets Engine Usage in Jenkins via Approles
¶
We have started to migrate to the
Jenkins Vault Plugin
.
The flow for using an GCP Secrets Engine in Jenkins is:
Mermaid Code:
sequenceDiagram
    box teal JENKINS
    participant SRE
    participant jenkcred as Jenkins Credential
    participant jenkjob as Jenkins Job
    participant approle as Approle Role
    end
    box KEEPER
    participant Vault
    participant gcpse as GCP Secrets Engine
    participant gcpser as GCP Secrets Engine Roleset
    end
    box rgb(59, 165, 196) GCP
    participant GCP
    end
    SRE->>jenkcred: Manually enter Role ID, Secret ID, and Path into a Jenkins credential
    jenkcred->>jenkjob: Jenkins credential is called inside a Jenkinsfile in a job.
    jenkjob->>Vault: Auth request to Vault with Approle
    Vault->>gcpse: Credentials  request (GCP Access Token) from GCP Secrets Engine
    gcpse->>gcpser: Credentials limited in scope by GCP Secrets Engine Roleset
    gcpser-->>gcpse: Roleset (service account) Access Token passed back to GCP Secrets Engine
    gcpse-->>jenkjob: Credentials  request (GCP Access Token) returned to Jenkins job
    jenkjob->>GCP: Jenkins job accesses GCP resources
To access an GCP secrets engine, you can use the below as a template with the correct paramaters. You can set the
paramsForLibrary
at the
step
,
stage
, or
globalParams
level.
This example is for the
step
.
stage
(
'CONNECT TO GKE & GAR'
)
{
steps
{
script
{
sreUtils
.
figlet
(
env
.
STAGE_NAME
)
def
paramsForLibrary
=
[
gcpProjectId:
"gcp-etigcp-nprd-12855"
,
// GCP Project ID
gcpVaultEnv:
"gcp_k8sec_dev_1"
,
// Vault GCP Secrets Engine Name/Path
gcpLoginVaultNamespace:
"eticloud/apps/securecn"
,
// Vault Namespace
jenkinsApproleCredsId:
"securecn-ci-jenkins-approle"
,
// Jenkins Vault Approle Credentials ID
vaultrolename:
"kubernetes-role"
,
// Vault GCP Secrets Engine Roleset Name
]
paramsForLibrary
[
"gcpZone"
]
=
"${CLUSTER_ZONE}"
sreGCP
.
gcpLoginServiceAcctWithAccessToken
(
paramsForLibrary
)
// An SRE Pipeline Library function that authenticates to Vault via Approle, returns a GCP access token, and sets the token as an environment variable + authenticates gcloud CLI
sreGCP
.
gkeAccessCluster
(
paramsForLibrary
,
"${CLUSTER_NAME}"
)
// An SRE Pipeline Library function that uses the above authentication to create the kubeconfig file and authenticate to the GKE cluster (via gcloud CLI)
paramsForLibrary
[
"vaultrolename"
]
=
"gar-publish-role"
// Switch to another Vault GCP Secrets Engine Roleset
sreUtils
.
garCloudLogin
(
paramsForLibrary
)
// An SRE Pipeline Library function that calls the 'sreGCP.gcpLoginServiceAcctWithAccessToken' function and authenticates to the GAR + GCR Cloud
}
// script
}
// steps
}
// stage('CONNECT TO GKE & GAR')
GCP Secrets Engine Usage in GHA (Github Actions)
¶
We have started to use the
Vault Github Action
for secrets retrieval and approle integrations. The flow for using an GCP Secrets Engine in GHA is:
Mermaid Code:
sequenceDiagram
    box rgb(100, 100, 100) GHA [Github Actions]
    participant SRE
    participant ghasec as GHA Org/Repo Secrets
    participant ghaw as GHA Workflow
    participant approle as Approle Role
    end
    box KEEPER
    participant Vault
    participant gcpse as GCP Secrets Engine
    participant gcpser as GCP Secrets Engine Roleset
    end
    box rgb(59, 165, 196) GCP
    participant GCP
    end
    SRE->>ghasec: Manually enter Role ID, Secret ID, and Path into a Jenkins credential
    ghasec->>ghaw: Jenkins credential is called inside a Jenkinsfile in a job.
    ghaw->>Vault: Auth request to Vault with Approle
    Vault->>gcpse: Credentials  request (GCP Access Token) from GCP Secrets Engine
    gcpse->>gcpser: Credentials limited in scope by GCP Secrets Engine Roleset
    gcpser-->>gcpse: Roleset (service account) Access Token passed back to GCP Secrets Engine
    gcpse-->>ghaw: Credentials  request (GCP Access Token) returned to Jenkins job
    ghaw->>GCP: Jenkins job accesses GCP/gcloud cli resources with roleset Access Token
To access an GCP secrets engine, you can use the below as a template with the correct inputs/configurations.
The example below is for accessing GAR (Google Artifact Registry) using approles + GCP Secrets Engine:
on
:
workflow_call
:
# allow reuse of this workflow in other repos
inputs
:
gcp-project-name
:
description
:
GCP Project name
required
:
false
default
:
"eticloud-scratch"
type
:
string
secrets
:
vault-approle-role-id
:
description
:
Vault Approle role id for default (eticloud) namespace
required
:
true
vault-approle-secret-id
:
description
:
Vault Approle secret id for default (eticloud) namespace
required
:
true
vault-venture-approle-role-id
:
description
:
Vault Approle role id for a specific venture namespace
required
:
false
vault-venture-approle-secret-id
:
description
:
Vault Approle secret id for a specific venture namespace
required
:
false
ghcr-username
:
description
:
GHCR docker registry username
required
:
true
ghcr-token
:
description
:
GHCR docker registry token
required
:
true
ghcr-org-token
:
description
:
GHCR docker registry token
required
:
true
permissions
:
contents
:
read
id-token
:
write
packages
:
write
# needed to push docker image to gar or ecr
jobs
:
build-image
:
name
:
Build & Push docker image
runs-on
:
${{ inputs.runner }}
container
:
image
:
${{ inputs.runner-docker-image }}
options
:
--user root
credentials
:
username
:
${{ secrets.ghcr-username }}
password
:
${{ secrets.ghcr-token }}
env
:
GIT_BRANCH
:
${{ github.head_ref || github.ref_name }}
steps
:
#region GAR LOGIN
# Set the vault secret engine path in accordance to the project name
-
name
:
Switch Case Action
id
:
switch-case
uses
:
dkershner6/switch-case-action@v1
with
:
default
:
'gcp_eticloud_scratch'
conditionals-with-values
:
|
${{ inputs.gcp-project-name == 'k8sec-dev' }}  => gcp_k8sec_dev_1
${{ inputs.gcp-project-name == 'eticloud-scratch' }} => gcp_eticloud_scratch
${{ inputs.gcp-project-name == 'eticloud-dev' }} => gcp_eticloud_dev
${{ inputs.gcp-project-name == 'eticloud' }} => gcp_eticloud
# Using the Approle strategy, grab the GCP gar-publish-role for authentication
-
name
:
Get GCP Role Access Token
uses
:
hashicorp/vault-action@v2.7.4
with
:
url
:
${{ vars.KEEPER_URL }}
method
:
approle
roleId
:
${{ secrets.vault-venture-approle-role-id != '' && secrets.vault-securecn-approle-role-id || secrets.vault-approle-role-id }}
secretId
:
${{ secrets.vault-venture-approle-role-id != '' && secrets.vault-securecn-approle-secret-id || secrets.vault-approle-secret-id }}
namespace
:
${{ secrets.vault-venture-approle-role-id != '' && vars.VAULT_VENTURE_NAMESPACE || vars.VAULT_NAMESPACE }}
secrets
:
|
${{ steps.switch-case.outputs.value }}/roleset/gar-publish-role/token  token | GCP_ACCESS_TOKEN
# Get the GCP roleset access token from the Vault GCP Engine and authenticate
-
name
:
Login to Google Artifact Registry (GAR)
id
:
gcp-auth
run
:
|
echo $GCP_ACCESS_TOKEN > ${{ env.GITHUB_WORKSPACE }}/tokenFile.txt
gcloud config set auth/access_token_file ${{ env.GITHUB_WORKSPACE }}/tokenFile.txt
gcloud auth configure-docker ${{ env.GAR_PRIVATE_REGISTRY }} --access-token-file ${{ env.GITHUB_WORKSPACE }}/tokenFile.txt --quiet
#endregion
2024-06-07