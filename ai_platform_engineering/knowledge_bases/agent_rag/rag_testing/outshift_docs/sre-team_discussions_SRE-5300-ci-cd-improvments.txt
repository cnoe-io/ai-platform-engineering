CI/CD Improvement Recommendations
¶
This document captures the goals and tasks for improving our CI/CD workflows.
Current CICD
High-Level Goals
How
Current CICD
¶
Currently (12 April 2023), ETI platform provides an automated CI/CD steps, in order to deploy new application we should:
* Add Jenkinsfile on app repository in order to automate build
* Create helm chart for theis app under "deploy" folder based on
platform-demo
repository.
* Create deployment repository for this app named "app-name-deployment" which will contains helm values files and applicationset needed to create argocd app for our application to deploy it. 
* Add cluster config (where we deploy our application) on "sre-configs-cluster" repository
* For now, all required repo have been created, we will move to Jenkins, in order to create ci/cd jobs, we should execute this job
creae-new-multibranch-pipeline
* Create argocd applicationset and argocd app using this jenkins job
create-new-argocd-apps
* Check application deployment status
High-Level Goals
¶
simplify deployment way
Make sure deployment best practices are repected
Manage cluster resources (nodes)
High avalibility
Avoid code duplication (copy/paste) in order to centralize helm chart template (maintenance more easily).
Secret management: Avoid pushing secrets (plain text) on git, use vault
Security & Resiliency
Monitoring of deployed application
FinOps: reduce cloud costs (improve cloud resource usage by using automated workflows to stop unused env (dev) on time off)
Cloud:
Add tags on deployed resources in order to keep sync between IaC and console
Less priviliges: remove stars from AWS IAM policies, give less priviliges
How
¶
Simplify deployment way:
Create a single deployment repository for all components related to the same application
(for example, if on our application source code, we have 3 components each of them will be deployed, we should create a single deployment repo)
Create applicationSet per application/env(dev or staging/prod) instead of applicationSet per application per env, for applications that has multiple components to be deployed, create one applicationSet per env(dev or staging/prod) instead of application per component per env
Make sure deployment best practices are repected:
Define imagePullsecret as var on values
Define "dimage" vamue on default values because it will be used on all env (dev/staging and prod)
Remove namespace option from all k8s resources and create namespace resource : in argocd app it was defined
Configure Liveness, readiness and startup probes
Keep configMap manifest file clean and define its data values on values.yaml file & use import configMap data instead of duplicated declaration (envFrom instead of env section on deployment spec)
Add resources limit and requests to manage infra resources.
Manage cluster resources (nodes):
In order to control application deployment, we should add tolerations and affinity to be sure application are deployed on dedicated nodes and nodes accept dedicated applications which will be a good manner to manage cluster nodes (ressources).
High avalibility:
Add PodAntiAffinity to be sure workloads are distrubuted on different nodes not on the same nodes.
Add pod disruption budget PDB allows to limit the disruption to your application when its pods need to be rescheduled for some reason (such as upgrades)
Add HPA (scale pods)
Add autoscaling (deploy Cluster Autoscaler to scale nodes)
Avoid code duplication (copy/paste):
Create generic helm chart (template) which will be used ad dependencies on all our application helm charts, instead of cloning platform-demo template repository ==> centralize helm chart management (best practices will be implemented). Below an overview of generic helm charts values file:
```yaml
    # nameOverride -- name of the chart/release to override 'generic-app' with
    nameOverride:
# appNameLabelOverride -- app.kubernetes.io/name label & selectors on this label
appNameLabelOverride: ""

# appInstanceLabelOverride -- Override app.kubernetes.io/instance label & selectors on this label
appInstanceLabelOverride: ""

# appVersionOverride -- Override app.kubernetes.io/version label & selectors on this label
appVersionOverride: ""

# env -- name of the environment, one of ['prod', 'staging', 'dev']
env:

##
# Pods configuration
##

# Container image to use
image:
# pods.image.name -- image repository/name
name:

# pods.image.tag -- image tag
tag:

# pods.image.pullPolicy -- image pullPolicy
pullPolicy: IfNotPresent

# pods.image.pullSecrets -- Optional array of imagePullSecrets containing private registry credentials
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
pullSecrets: []
# - name: secretName

pods:
# pods.controller -- controller used to schedule pods
# Can either be 'deployment', 'statefulset' or 'daemonset'
controller: deployment

# pods.replicas -- amount of desired pod(s) replica(s)
# Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#replicas
replicas:

# Specify revisionHistoryLimit (deployments only)
# Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy
revisionHistoryLimit: 3

# The update strategy to apply for the deployment, statefulset or daemonset
##
strategy: {}
#  rollingUpdate:
#    maxUnavailable: 1
#  type: RollingUpdate

# Custom command to use for the container
command: []

# Custom arguments to use for the container
args: []

# Additional labels and annotations for the deployment, statefulset or daemonset
labels: {}
#  key: value
annotations: {}
#  key: value

# Additional labels and annotations for the pods
podLabels: {}
#  key: value
podAnnotations: {}
#  key: value

# Healthcheck probes
livenessProbe: {}
readinessProbe: {}

# Resources allocation for the containers
resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #   cpu: 500m
    #   memory: 512Mi

ports:
    - containerPort: 8080

# Node labels for pod assignment
# Ref: https://kubernetes.io/docs/user-guide/node-selection/
nodeSelector: {}

## Node tolerations for server scheduling to nodes with taints
## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
##
tolerations: []
#  - key: "key"
#    operator: "Equal|Exists"
#    value: "value"
#    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

# DNS Policy
dnsPolicy: ClusterFirst

# Affinity configuration
affinity:
    # This allows you to automatically define anti-affinity rules
    antiAffinity:
    enabled: false
    type: hard  # Can be either 'hard' or 'soft'
    topologyKey: kubernetes.io/hostname

    rules: {}

# Environment variables
env: []
    # - name: key
    #   value: val
    # - name: other_key
    #    valueFrom:
    #      configMapKeyRef:
    #        name: config
    #        key: nice-key

envFrom: []
    # - configMapRef:
    #     name: config
    # - secretRef:
    #     name: config

# Volumes and mounts
volumes: []
    # - name: storage
    #   emptyDir: {}

volumeMounts: []
    # - name: storage
    #   mountPath: /mnt/storage

# Security
securityContext: {}

# Init containers configuration
initContainers: []

# Additional containers for the pods
additionalContainers: []

##
# Horizontal Pod Autoscaler configuration
##

# Only works for 'deployments' and 'statefulsets'
horizontalPodAutoscaler:
enabled: false
minReplicas: 1
maxReplicas: 2
targetAverageCPUUtilization: 60

##
# Service configuration
##

service:
enabled: false
type: ClusterIP
ports:
    - port: 80
    targetPort: 8080
    protocol: TCP
    name: http

##
# Ingress configuration
##

ingress:
enabled: false
annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

path: /
pathType: Prefix

ingressClassName: ""

service:
    port:
    name: http

hosts: []
    # - example.com
tls: []
    # - hosts:
    #     - example.com

##
# Pod Disruption Budget configuration
##

podDisruptionBudget:
enabled: false
minAvailable: 1

##
# ConfigMaps management
##

configMaps: {}
# foo:
#   FOO: bar

##
# Secrets management
##

secrets: {}
# super_secret:
#   key: sensitive_value
# dockerconfigjson/image-pull: |
#   .dockerconfigjson: {}
```
Secret management:
Add .pre-commit file on all repository and install pre-commit binary in order to avoid secrets on git (plain text) and use vault + external secret
Security & Resiliency:
Implement MTLS (Mutual TLS) to secure kubenetes workflow traffic
Implement circuit Breaker which is an important pattern for creating resilient microservice applications. Circuit breaking allows you to write applications that limit the impact of failures, latency spikes
 ==> Use ISTIO (more details here
https://istio.io/latest/docs/concepts/
)
Monitoring of deployed application:
Add labels for helm charts in order to monitor deployed apps
2023-08-25