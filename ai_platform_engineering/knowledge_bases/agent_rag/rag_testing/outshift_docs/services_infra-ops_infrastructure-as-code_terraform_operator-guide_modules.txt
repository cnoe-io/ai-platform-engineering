terraform development standards
terraform module developmost
terraform module documentation
terraform module outputs
terraform module testing
terraform module tooling
terraform module versioning
Terraform Module Development
¶
As both Terraform and the resources created by Terraform change over time, the Outshift Platform modules must change with them. To help ensure consistency across the lifecycle of modules, the SRE team follows a series of standards for module development.
Module Repository Conventions
¶
Beyond the required
module documentation
, there are several conventions a module repository should follow for ease-of-use.
Module Repository Default Branch
¶
Every module repository will use
main
as the default branch.
Module Versioning
¶
Modules will follow the
Semantic Versioning standard
.
Given a version number MAJOR.MINOR.PATCH, increment the:
MAJOR version when you make incompatible changes.
MINOR version when you add functionality in a backward compatible manner
PATCH version when you make backward compatible bug fixes
"Incompatible changes" in this context are changes that will require the resources in the module to be recreated when an
apply
occurs.
Module versioning is controlled by
commitizen
.
Module Documentation
¶
README.md
¶
At the root of each module repository there will be a
README.md
with the following sections:
The current version of the plaform module
A Changelog
The upstream Terraform public module, linked to the specific version
Prerequisite infrastructure list
Use-cases and examples
A list of input variables
All documentation will be updated before a Pull Request is submitted.
.cz.yaml
¶
At the root of each module repository there will be a
.cz.yaml
commitizen configuration file.
.cz.yaml configuration
.terraform-docs.yaml
¶
At the root of each module repository there will be a
.terraform-docs.yaml
terraform-docs configuration file.
.terraform-docs.yaml configuration
Module Current Version
¶
The current version matches the commitizen version and the Git version tag created by commitizen.
Examples:
EKS Current Version
- 2.0.1 as of 2023-09-29
EKS commitizen version
- 2.0.1 as of 2023-09-29
EKS version Git tag
- 2.0.1 as of 2023-09-29
Module Changelog
¶
A
CHANGELOG.md
will be generated with the
commitizen version bump command
.
The generated
CHANGELOG.md
will be a composite of all the previous commit messages.
Example EKS CHANGELOG.md
Module Use-cases and Examples
¶
There will be at least one example of an instatiation of the module in the
examples
folder at the root of a module repository.
If there are multiple use-cases, there will be multiple examples, each with a
README.md
explaining that use-case.
The examples will have comments in the Terraform indicating how to use the various parameters for the platform module.
EKS examples
Shared EKS cluster use-case
Share EKS cluster example Terraform
Module Input Variable List
¶
terraform-docs
will create the input variable list in the
README.md
.
Documentation Tooling
¶
terraform-docs
¶
terraform-docs
creates documentation for Terraform module repositories.
To update the
README.md
with terraform-docs, run the following command in the root of the repository:
terraform-docs -c .terraform-docs.yaml .
This command will update the
README.md
with the input variables in the module.
.terraform-docs.yaml configuration
¶
Example EKS .terraform.docs.yaml
formatter
:
"markdown
table"
# this is required
version
:
">=
0.13.0"
header-from
:
"eks_main.tf"
footer-from
:
""
recursive
:
enabled
:
false
path
:
modules
sections
:
hide
:
-
providers
-
modules
-
requirements
-
resources
-
data-sources
show
:
[]
content
:
|-
{{ .Inputs }}
{{ .Outputs }}
output
:
file
:
"README.md"
mode
:
inject
template
:
|-
<!-- BEGIN_TF_DOCS -->
## Variables
{{ .Content }}
<!-- END_TF_DOCS -->
output-values
:
enabled
:
false
from
:
""
sort
:
enabled
:
true
by
:
required
settings
:
anchor
:
true
default
:
true
description
:
true
escape
:
true
hide-empty
:
true
html
:
true
indent
:
2
lockfile
:
false
read-comments
:
true
sensitive
:
true
type
:
true
commitizen
¶
To ensure versioning consistency and to create a
CHANGELOG.md
in the module repository, a
commitizen
command will be employed.
The
type of commit
will determine the increment type.
Commitizen commands
¶
To update the version and the
CHANGELOG.md
, the following commands will be run locally in the root of the module repository:
First, a dry-run to ensure versioning is correct:
cz bump -ch --dry-run
Second, the bump, which creates a new commit and tag:
cz bump -ch
- updates the
.cz.yaml
version, the
CHANGELOG.md
, and creates a local version tag.
The version tag must be pushed separately from the code commit.
The commitizen command should be the last command run.
.cz.yaml configuration
¶
The
.cz.yaml
file at the root of the repository will have the following configuration:
---
commitizen
:
name
:
cz_conventional_commits
tag_format
:
$version
version
:
2.0.1
Intermodule Dependencies
¶
Modules often have resource dependencies. For example, EKS is dependent on a VPC with subnets existing. When those dependencies exist, modules will use
Terraform data sources
to retrieve that information.
Returning to the EKS/VPC dependency example, the EKS module requies the
vpc_name
input variable. The
vpc_name
determines the VPC ID, which in turn informs the module in which VPC to create the EKS resources.
vpc_name
parameter use
vpc_name   = "eks-prod-4-vpc" # The name of the VPC in which the cluster should be created.
aws_vpc data source
data
"aws_vpc"
"eks_vpc"
{
filter
{
name
=
"tag:Name"
values
=
[
var.vpc_name
]
}
}
This data source returns
VPC attributes
to the EKS module.
The
VPC ID is used in the EKS module
:
vpc_id          = data.aws_vpc.eks_vpc.id
Module Input Variables
¶
Module input variables specify the details of an instantiation of the module.
Input variables are divided into
Required
:
yes
or
no
by terraform-docs. An input variable is required when no default value is defined.
Required input variable example
variable
"vpc_name"
{
description
=
<<
EOF
The name of the VPC where the cluster will be created.
The vpc_name variable is used to look up the vpc id [eks_data.tf](./eks_data.tf)
EOF
type
=
string
sensitive
=
false
}
Optional input variable example
variable
"ami_date"
{
description
=
<<
EOF
The last date an AMI was produced. Should be in the format YYYY-MM-DD.
AMIs are produced on the 1st and 15th of each month. Examples:
2023-01-15
2023-02-01
EOF
type
=
string
default
=
""
validation
{
condition
=
var.ami_date
==
"" || can(regex("\\d\\d\\d\\d-\\d\\d-15|\\d\\d\\d\\d-\\d\\d-01"
,
var.ami_date
))
error_message
=
"The ami_date is not in the correct format: YYYY-MM-DD."
}
}
Module Naming Conventions
¶
Consistently naming resources allows engineers to quickly identify resources and allows automation to function.
Terraform Identifier Naming Conventions
¶
Terraform Identifiers
are all the Terraform-specific constructs like blocks, data sources, and input variables that make up Terraform code.
All identifiers will be lowercase.
All identifiers will use underscores rather than hyphens.
Examples
resource "vault_generic_secret" "private_key"
data "aws_vpc" "eks_vpc"
Cloud Resource Naming Conventions
¶
Modules will define and enforce the naming of cloud resources to the extent possible.
The Platform
Terraform Naming Conventions
Module Outputs
¶
Output values
expose information from one module to another. They cannot be used in separate Terraform/Atlantis
apply
s.
Platform modules will forward all outputs from upstream modules and will follow the
module naming conventions
Module Secret and Configuration Data
¶
The primary interface for storing and passing secret or configuration data, such as an IAM user secret pair or database connection information, is
Keeper
. Keeper is a Security & Trust Office managed instance of Hashicorp Vault.
Modules are instantiated with access to the
eticloud
namespace in Keeper by default.
The default
path
for modules to store secrets or configuration data will be:
/secrets/infra/<aws_account_name>/<region>/<resource_type_short_name>/<complete_resouce_name>
Modules will not store secret or configuration data outside of the
eticloud
namespace.
If secret or configuration data needs to be stored outside the
eticloud
namespace, it will be created in the instantiation of the module as a stand-alone resource.
Module inventory
¶
Inventory of our current modules
.
2024-08-01